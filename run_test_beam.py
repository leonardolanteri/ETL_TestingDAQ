import subprocess
import time
from pathlib import Path
from test_beam_config import Config as TBConfig

class TBRun:
    def __init__(self, tb_config:TBConfig):
        self.tb_config = tb_config

        self.run_number_path  = tb_config.project_directory / Path('daq/next_run_number.txt')
        self.etroc_ready_path = tb_config.project_directory / Path('daq/running_ETROC_acquisition.txt')
        self.scope_ready_path = tb_config.project_directory / Path('daq/running_acquisition.txt')

        # ---Initialize the set up--- #

        telescope_script = tb_config.project_directory / Path('telescope.py')
        subprocess.run([
            '/usr/bin/python3', str(telescope_script),
            '--configuration', 'cern_1', # make this generated by tb_config I think  or have a function above do it!
            '--kcu', tb_config.run_config.kcu_ip_address,
            '--offset', str(tb_config.run_config.offset),
            '--delay', str(tb_config.run_config.l1a_delay)
        ])

        # Run poke_board.py script with dark_mode
        poke_board_script = tb_config.project_directory / Path('poke_board.py')
        subprocess.run([
            '/usr/bin/python3', str(poke_board_script),
            '--configuration', 'modulev1',
            '--etrocs', '2',
            '--kcu', tb_config.run_config.kcu_ip_address,
            '--dark_mode'
        ])

    @property
    def etroc_daq_command(self) -> list[str]:
        etroc_daq_script = self.tb_config.test_beam.project_directory / Path('daq/etroc.py')
        return ['/usr/bin/python3', str(etroc_daq_script), 
            '--l1a_rate', '0', 
            '--ext_l1a', 
            '--kcu', self.tb_config.run_config.kcu_ip_address, 
            '--rb', '0', # why 0 here??? For multi should it be different?
            '--run', str(self.run_number), 
            '--lock', str(self.scope_ready_path)] # lock waits for scope to be ready
    @property
    def scope_daq_command(self) -> list[str]:
        # need to still pass in the configurable output directory for binaries!
        scope_daq_script = self.tb_config.project_directory / Path('daq/lecroy.py')
        return [
            '/usr/bin/python3', str(scope_daq_script), 
            '--runNum', str(self.run_number), 
            '--numEvents',  str(self.tb_config.run_config.num_events),
            '--sampleRate', str(self.tb_config.oscilloscope.sample_rate), 
            '--horizontalWindow', str(self.tb_config.oscilloscope.horizontal_window), 
            '--trigCh',     self.tb_config.oscilloscope.mcp_channel, 
            '--trig',       str(self.tb_config.oscilloscope.trigger), 
            '--vScale2',    str(self.tb_config.oscilloscope.v_scale_2), 
            '--vScale4',    str(self.tb_config.oscilloscope.v_scale_3), 
            '--vPos2',      str(self.tb_config.oscilloscope.v_position_2), 
            '--vPos3',      str(self.tb_config.oscilloscope.v_position_3), 
            '--timeoffset', str(self.tb_config.oscilloscope.time_offset), 
            '--trigSlope',  self.tb_config.oscilloscope.trigger_slope,
            '--display', "1"
            ]

    def take_run(self):
        self.is_etroc_ready = True
        subprocess.Popen(self.etroc_daq_command)
        time.sleep(15)
        # Wait for ETROC to be rady
        print("kcu_acquisition_flag ",self.is_etroc_ready)
        iteration = 0
        while not self.is_etroc_ready:
            #if args.force_acquisition: break
            if iteration == 0:
                print(f"Waiting for the KCU.")
            iteration+=1
        self.is_scope_ready = True # i am skeptical because this means etroc daq will start while osc just starts to run
        subprocess.run(self.scope_daq_command)
        self.is_etroc_ready = False
        self.is_scope_ready = False

    @property
    def is_etroc_ready(self) -> bool:
        return self.get_status(self.etroc_ready_path)

    @is_etroc_ready.setter
    def is_etroc_ready(self, status: bool):
        self.is_etroc_ready = self.set_status(self.etroc_ready_path, is_ready=status)

    @property
    def is_scope_ready(self) -> bool:
        return self.get_status(self.scope_ready_path)

    @is_scope_ready.setter
    def is_scope_ready(self, status: bool):
        self.is_scope_ready = self.set_status(self.scope_ready_path, is_ready=status)

    @staticmethod
    def get_status(path: Path) -> bool:
        with open(path) as file:
            status = file.read().strip()
        return status == "True"
    @staticmethod
    def set_status(path: Path, is_ready: bool = True):
        with open(path, "w") as f:
            value = "True" if is_ready else "False"
            f.write(value)
            f.truncate()
        return value == "True"

    @property   
    def run_number(self):
        with open(self.run_number_path, 'r') as file:
            run_number = file.read().strip()
        return run_number